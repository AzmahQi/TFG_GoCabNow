"use server";

import prisma from "@/lib/prisma";
import { hash } from "bcrypt";

/*
########
GET
########
*/

export async function getBasic(session) {}

// USER
export async function getUserByEmail(email) {
  const userData = await prisma.user.findUnique({
    where: { email: email },
  });

  return userData;
}

export async function getUserByNumber(number) {
  const userData = await prisma.user.findFirst({
    where: { contactNumber: number },
  });

  return userData;
}

// PROFILE
export async function getProfileByUserId(userId) {
  const userProfile = await prisma.profile.findFirst({
    where: { userId: userId },
  });

  return userProfile;
}

// ROLE
export async function getRoleByUserId(userId) {
  const roleData = await prisma.role.findFirst({
    where: { userId: userId },
    include: {
      RolesPermission: {
        select: {
          Permission: {
            select: {
              permissionName: true,
            },
          },
        },
      },
    },
  });

  return roleData.RolesPermission[0].Permission;
}

// RESERVATION

export async function getReservationsById (id) {

  return await prisma.reservation.findUnique({
    where: { id: id },
  });
}

export async function getReservationsByUserId(userId, role) {
  let reservations = null;

  if (role === "Standard") {
    reservations = await prisma.reservation.findMany({
      where: { clientId: userId },
    });
  } else if (role === "Driver") {
    reservations = await prisma.reservation.findMany({
      where: { driverId: userId },
    });
  }

  return reservations;
}

export async function getPendingReservations() {
  let reservations = await prisma.reservation.findMany({
    where: { driverId: null, reservationStatus: "PENDING" },
  });

  return reservations;
}

/*
########
UPDATE Remember to update de session information. if you modify Profile.
########
*/

//Reservation
export async function updateReservationStatus(id, status, driverId) {
  let updatedReservation = null;
  try {
    if (status === "CONFIRMED" || status === "CANCELLED" || status === "FULFILLED" ) {
      updatedReservation = await prisma.reservation.update({
        where: { id: id },
        data: {
          reservationStatus: status,
          driverId,
        },
      });
    } else {
      updatedReservation = await prisma.reservation.update({
        where: { id: id },
        data: {
          reservationStatus: status,
          driverId: null,
        },
      });
    }

    return updatedReservation;
  } catch (error) {
    console.error("Error updating reservation status:", error);
    throw error;
  }
}

/*
########
POST
########
*/

// User
export async function createUser(userData) {
  const { email, password, contactNumber, name, gender, birthDate } = userData;
  const hashedPassword = await hash(password, 12);
  let result = null;
  const formattedBirthDate = new Date(birthDate).toISOString();

  const existingUserByEmail = await prisma.user.findUnique({
    where: { email: email },
  });

  if (existingUserByEmail) {
    return { user: null, message: "User with this email already exists" };
  }

  const existingUserByNumber = await getUserByNumber(contactNumber);

  if (existingUserByNumber.length !== 0) {
    // Existing number
    if (existingUserByNumber.email !== null) {
      // already has an account to the related number
      return {
        user: null,
        message:
          "We already have an account with the number you introduced. Please try another number",
      };
    } else {
      // Update the existing user information
      result = await prisma.user.update({
        where: { contactNumber: existingUserByNumber.contactNumber },
        data: {
          email,
          password: hashedPassword,
        },
      });

      await prisma.profile.update({
        where: { userId: existingUserByNumber.id },
        data: {
          name,
          gender,
          birthDate: formattedBirthDate,
        },
      });
    }
  } else {
    //Create NEW USER
    result = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        contactNumber,
      },
    });

    await prisma.profile.create({
      data: {
        userId: result.id,
        name,
        gender,
        birthDate: formattedBirthDate,
      },
    });

    const roleRes = await prisma.role.create({
      data: {
        userId: result.id,
        roleName: "Default",
        description: "Autogenerated by registration",
      },
    });

    await prisma.rolesPermission.create({
      data: {
        roleId: roleRes.id,
        permissionId: 2,
      },
    });
  }

  const { password: newPassword, ...rest } = result;

  return { user: rest, message: "User created successfully" };
}

// Reservation
export async function createReservation(formData) {
  try {
    //Verify if we have the contactNumber on our system
    let isUser = await getUserByNumber(formData.contactNumber);

    if (!isUser) {
      //Creating user without authentication.
      isUser = await prisma.user.create({
        data: {
          contactNumber: formData.contactNumber,
        },
      });

      await prisma.profile.create({
        data: {
          userId: isUser.id,
          name: formData.name,
        },
      });

      const roleRes = await prisma.role.create({
        data: {
          userId: isUser.id,
          roleName: "Default",
          description: "Autogenerated by registration",
        },
      });
      await prisma.rolesPermission.create({
        data: {
          roleId: roleRes.id,
          permissionId: 2,
        },
      });
    }
    const reservationDate = new Date(formData.dateTime).toISOString();
    const numPassenger = parseInt(formData.numPassenger, 10);
    const numLuggage = parseInt(formData.luggage, 10);
    const newReservation = await prisma.reservation.create({
      data: {
        pickupLocation: formData.from,
        destination: formData.to,
        reservationDate,
        passengers: numPassenger,
        luggage: numLuggage,
        clientId: isUser.id,
        updatedAt: new Date(),
      },
    });

    return await getReservationsById(newReservation.id);
  } catch (error) {
    console.error("Error creating reservation:", error);
    throw error;
  }
}
